import 'dart:io';
import 'package:intl/intl.dart';
import 'package:path_provider/path_provider.dart';
import 'package:pdf/pdf.dart';
import 'package:pdf/widgets.dart' as pw;
import 'package:printing/printing.dart';
import 'database_helper.dart';

class PdfGenerator {
  static Future<String?> generateExamResultPdf(int examId) async {
    final dbHelper = DatabaseHelper.instance;
    final db = await dbHelper.database;
    
    // Fetch exam details
    final examResult = await db.query(
      'Exams',
      columns: ['exam_name', 'class_name', 'total_marks', 'exam_date'],
      where: 'exam_id = ?',
      whereArgs: [examId],
    );
    
    if (examResult.isEmpty) return null;
    
    final examData = examResult.first;
    final String examName = examData['exam_name'] as String;
    final String className = examData['class_name'] as String;
    final double totalMarks = (examData['total_marks'] as num).toDouble();
    final String examDate = examData['exam_date'] as String;

    // Fetch marks and stats
    final double highest = await dbHelper.getHighestMarksForExam(examId);
    final double average = await dbHelper.getAverageMarksForExam(examId);
    final List<Map<String, dynamic>> studentsMarksRaw = await dbHelper.getMarksByExam(examId);
    
    // Make a mutable copy
    List<Map<String, dynamic>> studentsMarks = List.from(studentsMarksRaw);
    
    // Sort students by obtained marks descending
    studentsMarks.sort((a, b) {
      double markA = a['obtained_marks'] != null ? (a['obtained_marks'] as num).toDouble() : -1;
      double markB = b['obtained_marks'] != null ? (b['obtained_marks'] as num).toDouble() : -1;
      return markB.compareTo(markA);
    });

    // Create document
    final pdf = pw.Document();

    pdf.addPage(
      pw.MultiPage(
        pageFormat: PdfPageFormat.a4,
        margin: const pw.EdgeInsets.only(left: 30, right: 30, top: 40, bottom: 40),
        header: (context) {
          return pw.Column(
            crossAxisAlignment: pw.CrossAxisAlignment.center,
            children: [
              pw.Text(
                "Local Coaching Center",
                style: pw.TextStyle(fontSize: 15, fontWeight: pw.FontWeight.bold),
              ),
              pw.SizedBox(height: 8),
              pw.Text(
                "Result Sheet: $examName",
                style: pw.TextStyle(fontSize: 12, fontWeight: pw.FontWeight.bold),
              ),
              pw.SizedBox(height: 20),
            ],
          );
        },
        footer: (context) {
          return pw.Container(
            alignment: pw.Alignment.center,
            margin: const pw.EdgeInsets.only(top: 10),
            child: pw.Text(
              "Generated by Admin",
              style: pw.TextStyle(fontSize: 8, fontStyle: pw.FontStyle.italic),
            ),
          );
        },
        build: (context) {
          return [
            // Setup Information
            pw.Row(
              children: [
                pw.Expanded(
                  child: pw.Column(
                    crossAxisAlignment: pw.CrossAxisAlignment.start,
                    children: [
                      _buildInfoRow("Class:", className),
                      pw.SizedBox(height: 8),
                      _buildInfoRow("Total Marks:", totalMarks.toString()),
                      pw.SizedBox(height: 8),
                      _buildInfoRow("Average Marks:", average.toStringAsFixed(2)),
                    ],
                  ),
                ),
                pw.Expanded(
                  child: pw.Column(
                    crossAxisAlignment: pw.CrossAxisAlignment.start,
                    children: [
                      _buildInfoRow("Date:", examDate),
                      pw.SizedBox(height: 8),
                      _buildInfoRow("Highest Marks:", highest.toString()),
                    ],
                  ),
                ),
              ],
            ),
            pw.SizedBox(height: 16),
            
            // Results Table
            pw.Table(
              border: pw.TableBorder.all(),
              columnWidths: const {
                0: pw.FixedColumnWidth(30),
                1: pw.FixedColumnWidth(60),
                2: pw.FlexColumnWidth(2),
                3: pw.FixedColumnWidth(80),
                4: pw.FixedColumnWidth(75),
              },
              children: [
                // Table Header
                pw.TableRow(
                  decoration: const pw.BoxDecoration(color: PdfColors.grey),
                  children: [
                    _buildHeaderCell("Rank"),
                    _buildHeaderCell("Student ID"),
                    _buildHeaderCell("Student Name", align: pw.TextAlign.left),
                    _buildHeaderCell("Obtained Marks"),
                    _buildHeaderCell("Percentage"),
                  ],
                ),
                // Table Content
                ...studentsMarks.asMap().entries.map((entry) {
                  int index = entry.key;
                  int rank = index + 1;
                  var student = entry.value;
                  
                  String marksStr;
                  String percentageStr;
                  
                  if (student['obtained_marks'] == null) {
                    marksStr = "Absent";
                    percentageStr = "N/A";
                  } else {
                    double marks = (student['obtained_marks'] as num).toDouble();
                    marksStr = marks.toString();
                    double percentage = (marks / totalMarks) * 100;
                    percentageStr = "${percentage.toStringAsFixed(2)}%";
                  }
                  
                  final bool isEven = index % 2 == 0;
                  final color = isEven ? PdfColors.white : PdfColors.grey100;

                  return pw.TableRow(
                    decoration: pw.BoxDecoration(color: color),
                    children: [
                      _buildCell(rank.toString()),
                      _buildCell(student['unique_student_id'].toString()),
                      _buildCell(student['name'].toString(), align: pw.TextAlign.left),
                      _buildCell(marksStr),
                      _buildCell(percentageStr),
                    ],
                  );
                }),
              ],
            ),
          ];
        },
      ),
    );

    // Save and Share PDF
    final outputDir = await getTemporaryDirectory();
    final timestamp = DateFormat('yyyyMMdd_HHmmss').format(DateTime.now());
    final classClean = className.replaceAll(' ', '');
    final examClean = examName.replaceAll(' ', '_');
    final filename = "Result_${classClean}_${examClean}_$timestamp.pdf";
    final file = File('${outputDir.path}/$filename');
    
    await file.writeAsBytes(await pdf.save());

    // Prompt user to print/share
    await Printing.sharePdf(
        bytes: await pdf.save(), filename: filename);

    return file.path;
  }
  
  static pw.Widget _buildInfoRow(String title, String value) {
    return pw.Row(
      mainAxisSize: pw.MainAxisSize.min,
      children: [
        pw.Text(
          title, 
          style: pw.TextStyle(color: PdfColors.blue900, fontWeight: pw.FontWeight.bold, fontSize: 10)
        ),
        pw.SizedBox(width: 8),
        pw.Text(
          value, 
          style: const pw.TextStyle(fontSize: 10)
        ),
      ],
    );
  }

  static pw.Widget _buildHeaderCell(String text, {pw.TextAlign align = pw.TextAlign.center}) {
    return pw.Padding(
      padding: const pw.EdgeInsets.all(8.0),
      child: pw.Text(
        text,
        textAlign: align,
        style: pw.TextStyle(color: PdfColors.white, fontWeight: pw.FontWeight.bold, fontSize: 10),
      ),
    );
  }

  static pw.Widget _buildCell(String text, {pw.TextAlign align = pw.TextAlign.center}) {
    return pw.Padding(
      padding: const pw.EdgeInsets.all(8.0),
      child: pw.Text(
        text,
        textAlign: align,
        style: const pw.TextStyle(fontSize: 10),
      ),
    );
  }
}
